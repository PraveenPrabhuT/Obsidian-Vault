/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => YoutubeTemplatePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/modals/insert-template.ts
var import_obsidian5 = require("obsidian");

// src/utils/constants.ts
var NO_VIDEO_ERROR = "No video found";
var NO_CHANNEL_ERROR = "No video found";
var NO_INTERNET_ERROR = "No internet connection";
var WRONG_API_KEY_ERROR = "API key is wrong";
var NO_INTERNET_CATCHING_ERROR = "net::ERR_INTERNET_DISCONNECTED";
var ROOT_FOLDER = "/";
var DEFAULT_CHAPTER_FORMAT = ' - "{{chapter}}"\n';
var DEFAULT_HASHTAG_FORMAT = ' - "#{{hashtag}}"\n';
var DEFAULT_TEMPLATE = `---
tags:
  - type/youtube
aliases: 
title: "{{title}}"
channel_name: "{{channelName}}"
subscribers: {{subscribers}}
length: "{{length}}"
publish_date: "{{publishDate}}"
chapters: 
{{chapters}}
hashtags: 
{{hashtags}}
thumbnail: "![[{{thumbnail}}]]"
description: "{{description}}"
note_created: "{{noteCreated}}"
note_modifiend: "{{noteCreatedDateTime}}"
youtube_url: "{{youtubeUrl}}"
template-type: "YouTube"
template-version: "1.0"
---

![[{{thumbnail}}]]

<iframe title="{{title}}" src="https://www.youtube.com/embed/{{id}}?feature=oembed" height="113" width="200" style="aspect-ratio: 1.76991 / 1; width: 100%; height: 100%;" allowfullscreen="" allow="fullscreen"></iframe>


# \u{1F30D} What It's About
- 

# \u{1F50D} How I Discovered IT
- 

# \u{1F9E0} Thoughts
- 

## What I Liked About IT
- 

## What I Didn't Like About it
- 

# \u270D\uFE0F The Video in 3 Sentences

# \u270D\uFE0F My Top 3 Quotes

# \u{1F3A8} Impressions

# \u2618\uFE0F How the Video Changed Me

# \u{1F4D2} Summary + Notes

# \u{1F970} Who Would Like it ?
- 

# \u{1F4DA}Related Videos
-  
`;

// src/actions/insert-action.ts
var import_obsidian4 = require("obsidian");

// src/apis/youtube.ts
var import_obsidian3 = require("obsidian");

// src/utils/parser.ts
var import_obsidian = require("obsidian");
function parseVideoId(url) {
  const regex = /(youtu.*be.*)\/(watch\?v=|embed\/|v|shorts|)(.*?((?=[&#?])|$))/gm;
  const result = regex.exec(url);
  return result ? result[3] : null;
}
function checkPathTemplate(template) {
  if (template.startsWith("/")) {
    throw new Error("You can't use '/' at the beginning of the path.");
  }
  if (!template.endsWith(".md")) {
    throw new Error("The path template should end with '.md' extension.");
  }
}
function parseChapters(description) {
  const lines = description.split("\n");
  const regex = /(\d{0,2}:?\d{1,2}:\d{2})/g;
  const chapters = [];
  for (const line of lines) {
    const matches = line.match(regex);
    if (matches) {
      const ts = matches[0];
      const title = line.split(" ").filter((l) => !l.includes(ts)).join(" ");
      chapters.push({
        timestamp: ts,
        title
      });
    }
  }
  return chapters;
}
function parseISODuration(data) {
  const duration = import_obsidian.moment.duration(data);
  return `${duration.hours() > 0 ? duration.hours() + ":" : ""}${duration.minutes() > 9 ? duration.minutes() : `0${duration.minutes()}`}:${duration.seconds() > 9 ? duration.seconds() : `0${duration.seconds()}`}`;
}
function filterStringData(text) {
  return text.replace(/"(.*?)"/g, "\xAB$1\xBB").replace(/["]/g, "");
}

// src/utils/file.ts
var import_obsidian2 = require("obsidian");
var illegalRe = /[\/\?<>\\:\*\|"]/g;
var controlRe = /[\x00-\x1f\x80-\x9f]/g;
var reservedRe = /^\.+$/;
var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
var windowsTrailingRe = /[\. ]+$/;
function truncate(sanitized, length) {
  const uint8Array = new TextEncoder().encode(sanitized);
  const truncated = uint8Array.slice(0, length);
  return new TextDecoder().decode(truncated);
}
function sanitize(input, replacement) {
  const sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
  return truncate(sanitized, 255);
}
function sanitizeFilename(text, options) {
  const replacement = (options == null ? void 0 : options.replacement) || "";
  const output = sanitize(text, replacement);
  return replacement === "" ? output : sanitize(output, "");
}
function findTFile(filepath, app) {
  const abstractFile = app.vault.getAbstractFileByPath(filepath);
  return abstractFile instanceof import_obsidian2.TFile ? abstractFile : null;
}
function getAllTFolders(element) {
  let folders = [];
  if (element instanceof import_obsidian2.TFolder) {
    folders.push(element);
    for (const child of element.children) {
      folders = folders.concat(getAllTFolders(child));
    }
  }
  return folders;
}
function isFolderExists(folder, app) {
  return !!app.vault.getAbstractFileByPath(folder);
}
function getFilenameExtension(filename) {
  const lastDotIndex = filename.lastIndexOf(".");
  return lastDotIndex !== -1 ? filename.slice(lastDotIndex + 1) : "";
}
function getAvailablePath(path, app) {
  function buildPath(path2, extenstion2, hasSlash2, modifier2) {
    return `${path2}${modifier2 !== 0 ? ` ${modifier2}` : ""}${extenstion2 ? `.${extenstion2}` : ""}${hasSlash2 ? "/" : ""}`;
  }
  const hasSlash = path.endsWith("/");
  if (hasSlash) path = path.slice(0, -1);
  const extenstion = getFilenameExtension(path);
  if (extenstion) path = path.slice(0, path.lastIndexOf("."));
  let modifier = 0;
  while (app.vault.getAbstractFileByPath(buildPath(path, extenstion, hasSlash, modifier))) {
    modifier++;
  }
  return buildPath(path, extenstion, hasSlash, modifier);
}

// src/apis/youtube.ts
var baseUrlForVideos = "https://www.googleapis.com/youtube/v3/videos?";
var baseUrlForChannels = "https://www.googleapis.com/youtube/v3/channels?";
async function getVideoData(videoUrl, settings) {
  var _a;
  try {
    const videoResponse = await (0, import_obsidian3.requestUrl)(
      baseUrlForVideos + `part=snippet,contentDetails&id=${parseVideoId(videoUrl)}&key=${settings.googleCloudApiKey}`
    ).json;
    if (videoResponse.items.length === 0) {
      throw new Error(NO_VIDEO_ERROR);
    }
    const channelsResponse = await (0, import_obsidian3.requestUrl)(
      baseUrlForChannels + `part=statistics&id=${videoResponse.items[0].snippet.channelId}&key=${settings.googleCloudApiKey}`
    ).json;
    if (channelsResponse.items.length === 0) {
      throw new Error(NO_CHANNEL_ERROR);
    }
    const thumbnailUrl = getBestThumbnailUrl(Object.values(videoResponse.items[0].snippet.thumbnails));
    return {
      id: videoResponse.items[0].id,
      title: filterStringData(videoResponse.items[0].snippet.title),
      channelName: filterStringData(videoResponse.items[0].snippet.channelTitle),
      subscribers: parseInt(channelsResponse.items[0].statistics.subscriberCount),
      length: parseISODuration(videoResponse.items[0].contentDetails.duration),
      //@ts-ignore
      publishDate: moment(videoResponse.items[0].snippet.publishedAt).format("YYYY-MM-DD"),
      thumbnail: "",
      thumbnailUrl,
      chapters: parseChapters(videoResponse.items[0].snippet.description).map(
        (chapter) => `${chapter.timestamp} ${filterStringData(chapter.title)}`
      ),
      hashtags: (_a = videoResponse.items[0].snippet.tags) != null ? _a : [],
      description: (videoResponse.items[0].snippet.description || "").replace(/\s+/g, " "),
      //@ts-ignore
      noteCreated: moment().format("YYYY-MM-DD"),
      //@ts-ignore
      noteCreatedDateTime: moment().format("YYYY-MM-DD HH:mm"),
      youtubeUrl: videoUrl
    };
  } catch (error) {
    if ((error == null ? void 0 : error.message) === NO_INTERNET_CATCHING_ERROR) {
      throw new Error(NO_INTERNET_ERROR);
    } else if ((error == null ? void 0 : error.status) && error.status.toString().startsWith("4")) {
      throw new Error(WRONG_API_KEY_ERROR);
    }
    throw Error((error == null ? void 0 : error.message) ? error.message : error);
  }
}
function getBestThumbnailUrl(availableThumbnails) {
  let bestThumbnailIdx = 0;
  for (let i = 1; i < availableThumbnails.length; i++) {
    if (availableThumbnails[i].width > availableThumbnails[bestThumbnailIdx].width) {
      bestThumbnailIdx = i;
    }
  }
  return availableThumbnails[bestThumbnailIdx].url;
}
async function downloadVideoThumbnail(app, createFolders, imageUrl, title, path) {
  const attachmentFolderPath = app.vault.getConfig("attachmentFolderPath");
  const filename = `${title}.${getFilenameExtension(imageUrl)}`;
  let fullpath;
  if (attachmentFolderPath.startsWith("./") && attachmentFolderPath.length === 2) {
    fullpath = `${path}/${filename}`;
  } else {
    const abstractFile = this.app.vault.getAbstractFileByPath(attachmentFolderPath);
    if (!(abstractFile instanceof import_obsidian3.TFolder)) {
      if (createFolders && !isFolderExists(attachmentFolderPath, app)) {
        await app.vault.createFolder(attachmentFolderPath);
      } else {
        throw new Error(
          `Attachment folder '${attachmentFolderPath}' does not exist. Check if the folder path is correct in your Settings \u2192 Files and links \u2192 Default location for new attachments. Or you can turn on option 'Create folders' in the plugin settings.`
        );
      }
    }
    fullpath = `${app.vault.getConfig("attachmentFolderPath")}/${filename}`;
  }
  const response = await (0, import_obsidian3.requestUrl)(imageUrl);
  await app.vault.createBinary(getAvailablePath(fullpath, app), response.arrayBuffer);
  return filename;
}

// src/utils/templater.ts
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(find, "g"), replace);
}
function processTemplateKey(key, videoData, settings) {
  switch (key) {
    case "chapters":
      return videoData.chapters.map((chapter) => replaceAll(settings.chapterFormat, "{{chapter}}", chapter)).join("");
    case "hashtags":
      return videoData.hashtags.map((hashtag) => replaceAll(settings.hashtagFormat, "{{hashtag}}", hashtag)).join("");
    default:
      return key in videoData ? videoData[key].toString() : "";
  }
}
function processPathTemplate(videoData, settings) {
  let template = settings.pathTemplate;
  Object.keys(videoData).filter((key) => template.includes(`{{${key}}}`)).forEach((key) => {
    template = replaceAll(template, `{{${key}}}`, sanitizeFilename(processTemplateKey(key, videoData, settings)));
  });
  return template;
}
async function getTemplate(settings, app) {
  let template;
  if (settings.useTemplateFile) {
    const file = findTFile(settings.templateFile, app);
    if (!file) throw new Error(`File '${settings.templateFile}' does not exist`);
    template = await app.vault.read(file);
  } else {
    template = settings.template;
  }
  return template;
}
async function processTemplate(videoData, settings, app) {
  let template;
  template = await getTemplate(settings, app);
  Object.keys(videoData).forEach((key) => {
    template = replaceAll(template, `{{${key}}}`, processTemplateKey(key, videoData, settings));
  });
  return template;
}

// src/actions/insert-action.ts
async function insertTemplate(videoUrl, app, plugin) {
  var _a;
  if (videoUrl.length < 11) {
    new import_obsidian4.Notice("Please use a valid URL (should be at least 11 characters)");
    return;
  }
  const data = await getVideoData(videoUrl, plugin.settings);
  if (!app.vault.getAbstractFileByPath(plugin.settings.folder)) {
    if (plugin.settings.createPaths && !isFolderExists(plugin.settings.folder, app)) {
      await app.vault.createFolder(plugin.settings.folder);
    } else {
      throw new Error(`Folder '${plugin.settings.folder}' does not exist`);
    }
  }
  let filepath;
  if (plugin.settings.usePathTemplate) {
    checkPathTemplate(plugin.settings.pathTemplate);
    filepath = (0, import_obsidian4.normalizePath)(processPathTemplate(data, plugin.settings));
  } else {
    filepath = (0, import_obsidian4.normalizePath)(`${plugin.settings.folder}/${sanitizeFilename(data.title)}.md`);
  }
  if (plugin.settings.allowDuplicates) filepath = getAvailablePath(filepath, app);
  if (findTFile(filepath, app)) {
    new import_obsidian4.Notice(`File ${filepath} already exists`);
  } else {
    const folderPath = filepath.substring(0, filepath.lastIndexOf("/"));
    if (plugin.settings.usePathTemplate && !isFolderExists(folderPath, app)) {
      await app.vault.createFolder(folderPath);
    }
    let thumbnailFileLink = "";
    const template = await getTemplate(plugin.settings, app);
    if (template.contains("{{thumbnail}}")) {
      thumbnailFileLink = (_a = await downloadVideoThumbnail(
        app,
        plugin.settings.createPaths,
        data.thumbnailUrl,
        sanitizeFilename(data.title),
        filepath.substring(0, filepath.lastIndexOf("/"))
      )) != null ? _a : "";
    }
    data.thumbnail = thumbnailFileLink;
    const dataToWrite = await processTemplate(data, plugin.settings, app);
    await app.vault.create(filepath, dataToWrite);
    const abstractFile = findTFile(filepath, app);
    if (abstractFile) {
      app.workspace.getLeaf().openFile(abstractFile);
    } else {
      new import_obsidian4.Notice(`Failed to create ${filepath}`);
    }
  }
}

// src/modals/insert-template.ts
var errorContainerId = "insert-template-modal__error";
var InsertTemplateModal = class extends import_obsidian5.Modal {
  constructor(app, plugin) {
    super(app);
    this.videoUrl = "";
    this.onSubmitClick = async () => {
      if (this.videoUrl.length < 11) {
        this.setErrorMessage(this.contentEl, "Please enter a valid URL (should be at least 11 characters)");
        return;
      }
      try {
        await insertTemplate(this.videoUrl, this.app, this.plugin);
        this.close();
      } catch (error) {
        if (this.plugin.settings.debugMode) console.error(error, error == null ? void 0 : error.message);
        switch (error == null ? void 0 : error.message) {
          case NO_VIDEO_ERROR:
            this.setErrorMessage(this.contentEl, "No video found with the given URL");
            break;
          case NO_CHANNEL_ERROR:
            this.setErrorMessage(this.contentEl, "No channel was found with the provided video URL");
            break;
          case NO_INTERNET_ERROR:
            this.setErrorMessage(this.contentEl, "Please check your internet connection");
            break;
          case WRONG_API_KEY_ERROR:
            this.setErrorMessage(this.contentEl, "Please check the API key in the settings");
            break;
          default:
            this.setErrorMessage(this.contentEl, `Unexpected error: ${error == null ? void 0 : error.message} `);
            break;
        }
      }
    };
    this.onEnterKeyPressing = (e) => {
      if (e.key === "Enter") {
        this.onSubmitClick();
      }
    };
    this.setErrorMessage = (contentEl, message) => {
      const errorContainer = contentEl.querySelector(`#${errorContainerId} `);
      if (errorContainer) {
        errorContainer.textContent = message;
      }
    };
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.classList.add("youtube-template-plugin");
    contentEl.createEl("h1", { text: "\u{1F517} Insert Template" });
    contentEl.addEventListener("keydown", this.onEnterKeyPressing);
    contentEl.createDiv({ cls: "insert-template-modal__input" }, (settingItem) => {
      new import_obsidian5.TextComponent(settingItem).setValue(this.videoUrl).setPlaceholder("URL of the video").onChange((value) => this.videoUrl = value);
    });
    const buttonContainer = contentEl.createDiv({ cls: "insert-template-modal__button-container" });
    contentEl.appendChild(buttonContainer);
    new import_obsidian5.Setting(buttonContainer).addButton(
      (btn) => btn.setButtonText("Insert (or press Enter)").setCta().onClick(this.onSubmitClick)
    );
    const errorContainer = contentEl.createDiv({
      cls: "insert-template-modal__error-container",
      attr: { id: errorContainerId }
    });
    contentEl.appendChild(errorContainer);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.removeEventListener("keydown", this.onEnterKeyPressing);
    contentEl.empty();
  }
};

// src/settings.ts
var import_obsidian6 = require("obsidian");
var DEFAULT_SETTINGS = {
  googleCloudApiKey: "",
  folder: ROOT_FOLDER,
  chapterFormat: DEFAULT_CHAPTER_FORMAT,
  hashtagFormat: DEFAULT_HASHTAG_FORMAT,
  template: DEFAULT_TEMPLATE,
  createPaths: true,
  allowDuplicates: true,
  usePathTemplate: false,
  pathTemplate: "",
  useTemplateFile: false,
  templateFile: "",
  debugMode: false
};
var YouTubeTemplatePluginSettingsTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "YouTube Template Plugin Settings" });
    new import_obsidian6.Setting(containerEl).setName("Google Cloud API Key").setDesc(
      createFragment((doc) => {
        doc.createEl("span", { text: "It's a secret API key that you can get from " });
        doc.createEl("a", {
          href: "https://console.cloud.google.com/apis/credentials",
          text: "Google Cloud Console"
        }).setAttr("target", "_blank");
      })
    ).addText(
      (text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.googleCloudApiKey).onChange(async (value) => {
        this.plugin.settings.googleCloudApiKey = value;
        await this.plugin.saveSettings();
      })
    ).setClass("youtube-template-plugin__wide-input");
    const rootFolder = this.app.vault.getAbstractFileByPath("/");
    const folders = getAllTFolders(rootFolder);
    const folderOptions = Object.fromEntries(folders.map((folder) => [folder.path, folder.path]));
    new import_obsidian6.Setting(containerEl).setName("Folder to save the notes").setDesc("Choose the folder where you want to save the notes. The default value is the root folder of your vault.").addDropdown(
      (dropdown) => dropdown.addOptions(folderOptions).setValue(this.plugin.settings.folder).onChange(async (value) => {
        this.plugin.settings.folder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Use path template").setDesc("Turn on if you want to use a template for the path where you want to save the notes.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.usePathTemplate).onChange(async (value) => {
        this.plugin.settings.usePathTemplate = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Path template").setDesc(
      "Choose the path where you want to save the notes. You can use all keywords that are available in the template (like {{title}}, {{channelName}} etc) and make something like 'YouTube/{{channelName}}/{{title}}.md'."
    ).addText(
      (text) => text.setValue(this.plugin.settings.pathTemplate).onChange(async (value) => {
        this.plugin.settings.pathTemplate = value;
        await this.plugin.saveSettings();
      })
    ).setClass("youtube-template-plugin__wide-input");
    new import_obsidian6.Setting(containerEl).setName("Create folders").setDesc("Turn on if you want to create the folders for the templates and attachments if they do not exist.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.createPaths).onChange(async (value) => {
        this.plugin.settings.createPaths = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Allow duplicates").setDesc(
      "Turn on if you want to allow creation of the files those have similar files already existing in your vault."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.allowDuplicates).onChange(async (value) => {
        this.plugin.settings.allowDuplicates = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Chapter format").setDesc("Make the template that will be used to insert chapters. You can use the following variables: {{chapter}}.").addText(
      (text) => text.setPlaceholder(DEFAULT_CHAPTER_FORMAT).setValue(this.plugin.settings.chapterFormat).onChange(async (value) => {
        this.plugin.settings.chapterFormat = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Hashtag format").setDesc("Make the template that will be used to insert hashtags. You can use the following variables: {{hashtag}}.").addTextArea(
      (text) => text.setPlaceholder(DEFAULT_HASHTAG_FORMAT).setValue(this.plugin.settings.hashtagFormat).onChange(async (value) => {
        this.plugin.settings.hashtagFormat = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Template").setDesc(
      "Make the template that will be used to create the note. You can use the following variables: {{title}}, {{channelName}}, {{subscribers}}, {{length}}, {{publishDate}}, {{thumbnail}} (to download thumbnail, file name will be returned), {{thumbnailUrl}} {{chapters}}, {{hashtags}}, {{description}}, {{noteCreated}}, {{noteCreatedDateTime}}, {{youtubeUrl}}."
    ).addTextArea(
      (text) => text.setValue(this.plugin.settings.template).onChange(async (value) => {
        this.plugin.settings.template = value;
        await this.plugin.saveSettings();
      })
    ).setClass("youtube-template-plugin__template-textarea");
    new import_obsidian6.Setting(containerEl).setName("Use template file").setDesc("Turn on if you want to use a file with a template to create the note instead of textarea above.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useTemplateFile).onChange(async (value) => {
        this.plugin.settings.useTemplateFile = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Template file").setDesc(
      "File with template that will be used to create the note. You can use the following You can use the following variables: {{title}}, {{channelName}}, {{subscribers}}, {{length}}, {{publishDate}}, {{thumbnail}} (to download thumbnail, file name will be returned), {{thumbnailUrl}} {{chapters}}, {{hashtags}}, {{description}}, {{noteCreated}}, {{noteCreatedDateTime}}, {{youtubeUrl}}."
    ).addText(
      (text) => text.setValue(this.plugin.settings.templateFile).onChange(async (value) => {
        this.plugin.settings.templateFile = value;
        await this.plugin.saveSettings();
      })
    ).setClass("youtube-template-plugin__wide-input");
    new import_obsidian6.Setting(containerEl).setName("Debug mode").setDesc(
      "Turn on if you want to see the debug/error messages in the console. Helpful for troubleshooting and issue reporting."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/main.ts
var YoutubeTemplatePlugin = class extends import_obsidian7.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new YouTubeTemplatePluginSettingsTab(this.app, this));
    this.addCommand({
      id: "youtube-insert-template",
      name: "Insert template",
      callback: () => {
        new InsertTemplateModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "youtube-insert-template-from-clipboard",
      name: "Insert template with URL from your clipboard",
      callback: async () => {
        await insertTemplate(await navigator.clipboard.readText(), this.app, this);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};

/* nosourcemap */